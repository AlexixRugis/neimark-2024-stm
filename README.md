Практическое задание
===

Вам дана заготовка проекта прошивки для микроконтроллера STM32F100RB. Такой контроллер присутствует на стандартной отладочной плате STM32VL-Discovery. Платы у вас, скорее всего нет, поэтому мы будем запускать прошивку на эмуляторе QEMU. Важно заметить, что эмулятор имеет ограниченную функциональность, и запускать на нём что-то сложное не получится. Но для наших целей сойдёт.


## Задача:

Вы должны решить следующие задачи:

1. Настройте newlib таким образом, чтобы функция `printf()` выводила текст в последовательный порт UART1. Вывод в последовательный порт осуществляется функцией `HAL_UART_Transmit`, пример использования вы найдёте в коде.

2. Добавить в реализацию функции `_sbrk()` счётчик количества вызовов данной функции

3. Создать обёртки для функций `malloc()` и `free()`, которые будут просто вызывать оригинальные версии этих функций, но при этом выполнять подсчёт количества вызовов

4. Написать функцию `print_stat()`, которая выведет при помощи `printf()` счётчики использования функций `malloc`, `free`, `_sbrk`

Дальше, вы должны запускать в бесконечном цикле функцию `function_to_investigate()` и затем `print_stat()`, чтобы счётчики печатались в последовательный порт.

Если у вас возникнут сложности, то пропустите задания 2 и 3 и просто продемонстрируйте, что `printf` работает правильно.

## Советы

Сперва скомпилируйте заготовку проекта командой `make` и запустите её при помощи скрипта `run-qemu.sh`. Чтобы увидеть текс, который контроллер посылает в последовательный порт, в окне QEMU нажмите View -> seial0, или же Ctrl+Alt+2. С периодичностью в одну секунду там будут появляться строки:

```
Hello, stm32 C developer!
Hello, stm32 C++ developer!
```

Если это происходит, ваша рабочая среда настроена правильно.


Большая часть кода является сгенерированной и для вас интереса не представляет. Вас будет интересовать файл `Core/Src/main.c`, вернее только функция `main()`. Вернее только бесконечный цикл `while(1)`, в котором работает код. Там есть вызов функции `cpp_code_entry_point()`. Эта функция ведёт в единственный файл, написанный на языке C++, файл `cpp-code/cpp-code.cpp`. В нём вы можете чувствовать себя спокойно, программируя на C++, а не на голом C. Только не используйте `std::cout` вместо `printf`, контроллер скорее всего не сможет вместить столько дополнительного кода из стандартной библиотеки.

Также, вас будут интересовать файлы

```
Core/Src/sysmem.c
Core/Src/syscalls.c
```

В них вы найдёте реализации функций из `sys/unistd.h`, о которых мы говорили на лекции. Куда-то туда вы можете добавить свои собственные переопределенные `malloc` и `free`.


## Настройка рабочей среды

Я использовал Ubuntu 22.04 LTS, но и на других дистрибутивах должно работать. Тем, кто используют Windows, придётся самим разобраться, как настроить рабочее окружение, тут мои полномочия - всё.

1. Установите компилятор: `sudo apt install gcc-arm-none-eabi`
`sudo apt-get install libstdc++-arm-none-eabi-newlib`

2. Установите виртуальную машину QEMU с поддержкой ARM: `sudo apt install qemu-system-arm`

3. Установите утилиту `make`, если по какой-то нелепой случайности она ещё не установлена на вашем компьютере


## Как сдавать результаты

- Сделайте форк данного репозитория

- Добавьте необходимый код

- Пришлите ссылку мне на AlexeyABulatov@yandex.ru с темой "Неймарк-интенсив 2024", в письме не забудьте представиться

- Вместо ссылки на форк репозитория можете прислать архив с кодом

- Перед началом разбора задания я добавлю в этот репозиторий коммит со своим решением
